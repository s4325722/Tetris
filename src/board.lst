   1               		.file	"board.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init_board
  15               	init_board:
  16               	.LFB0:
  17               		.file 1 "board.c"
   1:board.c       **** /*
   2:board.c       ****  * board.c
   3:board.c       ****  *
   4:board.c       ****  * Written by Peter Sutton.
   5:board.c       ****  *
   6:board.c       ****  * Board data is stored in an array of rowtype (which is wide enough
   7:board.c       ****  * to hold a bit for each column). The bits of the rowtype
   8:board.c       ****  * represent whether that square is occupied or not (a 1 indicates
   9:board.c       ****  * occupied). The least significant BOARD_WIDTH bits are used. The
  10:board.c       ****  * least significant bit is on the right.
  11:board.c       ****  */
  12:board.c       **** 
  13:board.c       **** #include "board.h"
  14:board.c       **** #include "pieces.h"
  15:board.c       **** #include "score.h"
  16:board.c       **** #include "led_display.h"
  17:board.c       **** 
  18:board.c       **** /*
  19:board.c       ****  * Function prototypes.
  20:board.c       ****  * Board.h has the prototypes for functions in this module which
  21:board.c       ****  * are available externally, and because we include "board.h" above
  22:board.c       ****  * we do not need to repeat those prototypes.
  23:board.c       ****  */
  24:board.c       **** int8_t piece_overlap(piece_type* piece, int8_t row_num);
  25:board.c       **** void check_for_completed_rows(void);
  26:board.c       **** 
  27:board.c       **** /*
  28:board.c       ****  * Global variables
  29:board.c       ****  *
  30:board.c       ****  */
  31:board.c       **** rowtype    board[BOARD_ROWS];
  32:board.c       **** piece_type current_piece;	/* Current dropping piece */
  33:board.c       **** int8_t     piece_row_num;	/* Current row number of the bottom of
  34:board.c       **** 							 * the current piece, -1 if have 
  35:board.c       **** 							 * no current piece  */
  36:board.c       **** 
  37:board.c       **** /* 
  38:board.c       ****  * Initialise board - no pieces (i.e. set the row data to contain
  39:board.c       ****  * all zeroes.)
  40:board.c       ****  */
  41:board.c       **** void init_board(void) {
  18               		.loc 1 41 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  24               	.LVL0:
  25               		.loc 1 41 0
  26 0000 E0E0      		ldi r30,lo8(board)
  27 0002 F0E0      		ldi r31,hi8(board)
  28 0004 8FE0      		ldi r24,lo8(15)
  29               	.LVL1:
  30               	.L2:
  42:board.c       **** 	uint8_t i;
  43:board.c       **** 
  44:board.c       **** 	for(i=0; i < BOARD_ROWS; i++) {
  45:board.c       **** 		board[i] = 0;
  31               		.loc 1 45 0 discriminator 2
  32 0006 1192      		st Z+,__zero_reg__
  33 0008 8150      		subi r24,lo8(-(-1))
  44:board.c       **** 	for(i=0; i < BOARD_ROWS; i++) {
  34               		.loc 1 44 0 discriminator 2
  35 000a 01F4      		brne .L2
  46:board.c       **** 	}
  47:board.c       **** 	
  48:board.c       **** 	/* -1 in piece_row_num indicates no current piece */
  49:board.c       **** 	piece_row_num = -1;
  36               		.loc 1 49 0
  37 000c 8FEF      		ldi r24,lo8(-1)
  38 000e 8093 0000 		sts piece_row_num,r24
  39               	/* epilogue start */
  50:board.c       **** }
  40               		.loc 1 50 0
  41 0012 0895      		ret
  42               		.cfi_endproc
  43               	.LFE0:
  45               	.global	copy_board_to_led_display
  47               	copy_board_to_led_display:
  48               	.LFB1:
  51:board.c       **** 
  52:board.c       **** /* 
  53:board.c       ****  * Copy board to LED display. Note that difference in definitions of
  54:board.c       ****  * rows and columns for the board and the LED display. The Tetris board
  55:board.c       ****  * has 15 rows (numbered from the bottom), each 7 bits wide (with the 
  56:board.c       ****  * 7 columns numbered as per the bits - i.e. least significant (0) on 
  57:board.c       ****  * the right). The LED display has 7 rows (0 at the top, 6 at the bottom) 
  58:board.c       ****  * with 15 columns (numbered from 0 at the bottom to 14 at the top).
  59:board.c       ****  */
  60:board.c       **** void copy_board_to_led_display(void) {
  49               		.loc 1 60 0
  50               		.cfi_startproc
  51 0014 CF92      		push r12
  52               	.LCFI0:
  53               		.cfi_def_cfa_offset 3
  54               		.cfi_offset 12, -2
  55 0016 DF92      		push r13
  56               	.LCFI1:
  57               		.cfi_def_cfa_offset 4
  58               		.cfi_offset 13, -3
  59 0018 EF92      		push r14
  60               	.LCFI2:
  61               		.cfi_def_cfa_offset 5
  62               		.cfi_offset 14, -4
  63 001a FF92      		push r15
  64               	.LCFI3:
  65               		.cfi_def_cfa_offset 6
  66               		.cfi_offset 15, -5
  67 001c 0F93      		push r16
  68               	.LCFI4:
  69               		.cfi_def_cfa_offset 7
  70               		.cfi_offset 16, -6
  71 001e 1F93      		push r17
  72               	.LCFI5:
  73               		.cfi_def_cfa_offset 8
  74               		.cfi_offset 17, -7
  75 0020 CF93      		push r28
  76               	.LCFI6:
  77               		.cfi_def_cfa_offset 9
  78               		.cfi_offset 28, -8
  79 0022 DF93      		push r29
  80               	.LCFI7:
  81               		.cfi_def_cfa_offset 10
  82               		.cfi_offset 29, -9
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 8 */
  86               	.L__stack_usage = 8
  87               	.LVL2:
  61:board.c       **** 	/* The board has BOARD_ROWS (e.g. 15), each of width BOARD_WIDTH.
  62:board.c       **** 	 * Board row 0 corresponds to LED display column bit 0 etc.
  63:board.c       **** 	 * The function updates our LED display to reflect the 
  64:board.c       **** 	 * current state of the board.
  65:board.c       **** 	 */
  66:board.c       **** 	int8_t board_row_num;
  67:board.c       **** 	int8_t board_col_num;
  68:board.c       **** 	uint16_t led_display_row;
  69:board.c       **** 	for(board_col_num = 0; board_col_num < BOARD_WIDTH; board_col_num++) {
  70:board.c       **** 		led_display_row = 0;
  71:board.c       **** 		for(board_row_num = BOARD_ROWS-1; board_row_num >= 0; board_row_num--) {
  72:board.c       **** 			led_display_row <<=1;
  73:board.c       **** 			led_display_row |= (board[board_row_num]>>board_col_num)&1;
  74:board.c       **** 			/* If the current piece covers this row - add it in also. */
  75:board.c       **** 			if(piece_row_num >= 0 && board_row_num >= piece_row_num &&
  88               		.loc 1 75 0
  89 0024 A091 0000 		lds r26,piece_row_num
  76:board.c       **** 					board_row_num < (piece_row_num + current_piece.y_dimension)) {
  90               		.loc 1 76 0
  91 0028 8A2F      		mov r24,r26
  92 002a 9927      		clr r25
  93 002c 87FD      		sbrc r24,7
  94 002e 9095      		com r25
  95 0030 2091 0000 		lds r18,current_piece+4
  96 0034 6C01      		movw r12,r24
  97 0036 C20E      		add r12,r18
  98 0038 D11C      		adc r13,__zero_reg__
  99 003a 60E0      		ldi r22,lo8(0)
 100 003c 70E0      		ldi r23,hi8(0)
  60:board.c       **** void copy_board_to_led_display(void) {
 101               		.loc 1 60 0
 102 003e C0E0      		ldi r28,lo8(current_piece)
 103 0040 D0E0      		ldi r29,hi8(current_piece)
 104 0042 C81B      		sub r28,r24
 105 0044 D90B      		sbc r29,r25
 106 0046 F6E0      		ldi r31,lo8(6)
 107 0048 EF2E      		mov r14,r31
 108 004a F12C      		mov r15,__zero_reg__
 109 004c 00C0      		rjmp .L5
 110               	.LVL3:
 111               	.L7:
  72:board.c       **** 			led_display_row <<=1;
 112               		.loc 1 72 0
 113 004e C901      		movw r24,r18
 114 0050 880F      		lsl r24
 115 0052 991F      		rol r25
 116               	.LVL4:
  73:board.c       **** 			led_display_row |= (board[board_row_num]>>board_col_num)&1;
 117               		.loc 1 73 0
 118 0054 F801      		movw r30,r16
 119 0056 2291      		ld r18,-Z
 120 0058 8F01      		movw r16,r30
 121 005a 30E0      		ldi r19,lo8(0)
 122 005c 0B2E      		mov r0,r27
 123 005e 00C0      		rjmp 2f
 124 0060 3595      	1:	asr r19
 125 0062 2795      		ror r18
 126 0064 0A94      	2:	dec r0
 127 0066 02F4      		brpl 1b
 128 0068 2170      		andi r18,lo8(1)
 129 006a 3070      		andi r19,hi8(1)
 130 006c 282B      		or r18,r24
 131 006e 392B      		or r19,r25
 132               	.LVL5:
  75:board.c       **** 			if(piece_row_num >= 0 && board_row_num >= piece_row_num &&
 133               		.loc 1 75 0
 134 0070 A7FD      		sbrc r26,7
 135 0072 00C0      		rjmp .L6
  75:board.c       **** 			if(piece_row_num >= 0 && board_row_num >= piece_row_num &&
 136               		.loc 1 75 0 is_stmt 0 discriminator 1
 137 0074 4A17      		cp r20,r26
 138 0076 04F0      		brlt .L6
 139 0078 4C15      		cp r20,r12
 140 007a 5D05      		cpc r21,r13
 141 007c 04F4      		brge .L6
  60:board.c       **** void copy_board_to_led_display(void) {
 142               		.loc 1 60 0 is_stmt 1
 143 007e FE01      		movw r30,r28
 144 0080 E40F      		add r30,r20
 145 0082 F51F      		adc r31,r21
  77:board.c       **** 				led_display_row |= 
  78:board.c       **** 						((current_piece.rowdata[board_row_num - piece_row_num]
  79:board.c       **** 							>>board_col_num)&1);
 146               		.loc 1 79 0
 147 0084 8081      		ld r24,Z
 148 0086 90E0      		ldi r25,lo8(0)
 149 0088 0B2E      		mov r0,r27
 150 008a 00C0      		rjmp 2f
 151 008c 9595      	1:	asr r25
 152 008e 8795      		ror r24
 153 0090 0A94      	2:	dec r0
 154 0092 02F4      		brpl 1b
  77:board.c       **** 				led_display_row |= 
 155               		.loc 1 77 0
 156 0094 8170      		andi r24,lo8(1)
 157 0096 9070      		andi r25,hi8(1)
 158 0098 282B      		or r18,r24
 159 009a 392B      		or r19,r25
 160               	.LVL6:
 161               	.L6:
 162 009c 4150      		subi r20,lo8(-(-1))
 163 009e 5040      		sbci r21,hi8(-(-1))
  71:board.c       **** 		for(board_row_num = BOARD_ROWS-1; board_row_num >= 0; board_row_num--) {
 164               		.loc 1 71 0
 165 00a0 FFEF      		ldi r31,hi8(-1)
 166 00a2 4F3F      		cpi r20,lo8(-1)
 167 00a4 5F07      		cpc r21,r31
 168 00a6 01F4      		brne .L7
  60:board.c       **** void copy_board_to_led_display(void) {
 169               		.loc 1 60 0
 170 00a8 F701      		movw r30,r14
 171 00aa E61B      		sub r30,r22
 172 00ac F70B      		sbc r31,r23
  80:board.c       **** 			}
  81:board.c       **** 		}
  82:board.c       **** 
  83:board.c       **** 		/* Copy this row to the LED display. Lower LED display 
  84:board.c       **** 		 * row numbers correspond to higher board column numbers
  85:board.c       **** 		 */
  86:board.c       **** 		display[6-board_col_num] = led_display_row;
 173               		.loc 1 86 0
 174 00ae EE0F      		lsl r30
 175 00b0 FF1F      		rol r31
 176 00b2 E050      		subi r30,lo8(-(display))
 177 00b4 F040      		sbci r31,hi8(-(display))
 178 00b6 3183      		std Z+1,r19
 179 00b8 2083      		st Z,r18
 180 00ba 6F5F      		subi r22,lo8(-(1))
 181 00bc 7F4F      		sbci r23,hi8(-(1))
  69:board.c       **** 	for(board_col_num = 0; board_col_num < BOARD_WIDTH; board_col_num++) {
 182               		.loc 1 69 0
 183 00be 6730      		cpi r22,7
 184 00c0 7105      		cpc r23,__zero_reg__
 185 00c2 01F0      		breq .L4
 186               	.LVL7:
 187               	.L5:
  69:board.c       **** 	for(board_col_num = 0; board_col_num < BOARD_WIDTH; board_col_num++) {
 188               		.loc 1 69 0 is_stmt 0 discriminator 1
 189 00c4 00E0      		ldi r16,lo8(board+15)
 190 00c6 10E0      		ldi r17,hi8(board+15)
  60:board.c       **** void copy_board_to_led_display(void) {
 191               		.loc 1 60 0 is_stmt 1 discriminator 1
 192 00c8 4EE0      		ldi r20,lo8(14)
 193 00ca 50E0      		ldi r21,hi8(14)
 194 00cc 20E0      		ldi r18,lo8(0)
 195 00ce 30E0      		ldi r19,hi8(0)
  73:board.c       **** 			led_display_row |= (board[board_row_num]>>board_col_num)&1;
 196               		.loc 1 73 0 discriminator 1
 197 00d0 B62F      		mov r27,r22
 198 00d2 00C0      		rjmp .L7
 199               	.LVL8:
 200               	.L4:
 201               	/* epilogue start */
  87:board.c       **** 	}
  88:board.c       **** #ifndef AVR
  89:board.c       **** 	display_board();
  90:board.c       **** #endif
  91:board.c       **** }
 202               		.loc 1 91 0
 203 00d4 DF91      		pop r29
 204 00d6 CF91      		pop r28
 205 00d8 1F91      		pop r17
 206 00da 0F91      		pop r16
 207 00dc FF90      		pop r15
 208 00de EF90      		pop r14
 209 00e0 DF90      		pop r13
 210 00e2 CF90      		pop r12
 211 00e4 0895      		ret
 212               		.cfi_endproc
 213               	.LFE1:
 215               	.global	have_current_piece
 217               	have_current_piece:
 218               	.LFB2:
  92:board.c       **** 			
  93:board.c       **** /*
  94:board.c       ****  * Checks whether have current piece
  95:board.c       ****  */
  96:board.c       **** int8_t have_current_piece(void) {
 219               		.loc 1 96 0
 220               		.cfi_startproc
 221               	/* prologue: function */
 222               	/* frame size = 0 */
 223               	/* stack size = 0 */
 224               	.L__stack_usage = 0
  97:board.c       **** 	return (piece_row_num != -1);
 225               		.loc 1 97 0
 226 00e6 81E0      		ldi r24,lo8(1)
 227 00e8 9091 0000 		lds r25,piece_row_num
 228 00ec 9F3F      		cpi r25,lo8(-1)
 229 00ee 01F4      		brne .L11
 230 00f0 80E0      		ldi r24,lo8(0)
 231               	.L11:
  98:board.c       **** }
 232               		.loc 1 98 0
 233 00f2 0895      		ret
 234               		.cfi_endproc
 235               	.LFE2:
 237               	.global	fix_piece_to_board
 239               	fix_piece_to_board:
 240               	.LFB7:
  99:board.c       **** 
 100:board.c       **** /*
 101:board.c       ****  * Add random piece, return false (0) if we can't add the piece - this
 102:board.c       ****  * means the game is over.
 103:board.c       ****  */
 104:board.c       **** int8_t add_random_piece(void) {
 105:board.c       **** 	current_piece = generate_random_piece();
 106:board.c       **** 	/* We add the piece at a position that ensures it will fit on 
 107:board.c       **** 	 * the board, even if rotated (i.e. we check it's maximum
 108:board.c       **** 	 * dimension and come down that many rows).
 109:board.c       **** 	 * This allows rotation without worrying
 110:board.c       **** 	 * about whether the piece will end up off the top of the 
 111:board.c       **** 	 * board or not.
 112:board.c       **** 	 */
 113:board.c       **** 	if(current_piece.x_dimension > current_piece.y_dimension) {
 114:board.c       **** 		piece_row_num = BOARD_ROWS - current_piece.x_dimension;
 115:board.c       **** 	} else {
 116:board.c       **** 		piece_row_num = BOARD_ROWS - current_piece.y_dimension;
 117:board.c       **** 	}
 118:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 119:board.c       **** 		/* Game is over */
 120:board.c       **** 		piece_row_num = -1; /* no current piece */
 121:board.c       **** 		return 0;
 122:board.c       **** 	} else {
 123:board.c       **** 		return 1;
 124:board.c       **** 	}
 125:board.c       **** }
 126:board.c       **** 
 127:board.c       **** /*
 128:board.c       ****  * Attempt to move the current piece to the left or right. 
 129:board.c       ****  * This succeeds if
 130:board.c       ****  * (1) the piece isn't all the way to the side, and
 131:board.c       ****  * (2) the board contains no pieces in that position.
 132:board.c       ****  * Returns 1 if move successful, 0 otherwise.
 133:board.c       ****  */
 134:board.c       **** int8_t attempt_move(int8_t direction) {	
 135:board.c       **** 	piece_type backup_piece;
 136:board.c       **** 	
 137:board.c       **** 	/*
 138:board.c       **** 	 * Make a copy of our piece in its current position (in case
 139:board.c       **** 	 * we need to restore it)
 140:board.c       **** 	 */
 141:board.c       **** 	copy_piece(&current_piece, &backup_piece);
 142:board.c       **** 	
 143:board.c       **** 	/*
 144:board.c       **** 	 * Move the piece template left/right, if possible (will only 
 145:board.c       **** 	 * fail if the piece is up against the side).
 146:board.c       **** 	 */
 147:board.c       **** 	if(direction == MOVE_LEFT) {
 148:board.c       **** 		if(!move_piece_left(&current_piece)) {
 149:board.c       **** 			return 0;
 150:board.c       **** 		}
 151:board.c       **** 	} else {
 152:board.c       **** 		if(!move_piece_right(&current_piece)) {
 153:board.c       **** 			return 0;
 154:board.c       **** 		}
 155:board.c       **** 	}
 156:board.c       **** 		
 157:board.c       **** 	/* 
 158:board.c       **** 	 * If we get here, piece is not at edge.
 159:board.c       **** 	 * Check that the board will allow a move (i.e. the pieces
 160:board.c       **** 	 * won't overlap).
 161:board.c       **** 	 */
 162:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 163:board.c       **** 		/*
 164:board.c       **** 		 * Current board position does not allow move.
 165:board.c       **** 		 * Restore original piece
 166:board.c       **** 		 */
 167:board.c       **** 		copy_piece(&backup_piece, &current_piece);
 168:board.c       **** 		return 0;
 169:board.c       **** 	}
 170:board.c       **** 	
 171:board.c       **** 	/* Move has been made - return success */
 172:board.c       **** 	return 1;
 173:board.c       **** }
 174:board.c       **** 
 175:board.c       **** 
 176:board.c       **** /*
 177:board.c       ****  * Attempt to drop the piece by one row. This succeeds unless there
 178:board.c       ****  * are squares blocked on the row below or we're at the bottom of
 179:board.c       ****  * the board. Returns 1 if drop succeeded, 
 180:board.c       ****  * 0 otherwise. (If the drop fails, the caller should add the piece
 181:board.c       ****  * to the board.)
 182:board.c       **** */
 183:board.c       **** int8_t attempt_drop_piece_one_row(void) {
 184:board.c       **** 	/*
 185:board.c       **** 	 * Check if the piece has
 186:board.c       **** 	 * reached the bottom of the board. Nothing to do in this
 187:board.c       **** 	 * case - return false - we can't drop it any further.
 188:board.c       **** 	 */
 189:board.c       **** 	if(piece_row_num == 0) {
 190:board.c       **** 		return 0;
 191:board.c       **** 	}
 192:board.c       **** 	
 193:board.c       **** 	/*
 194:board.c       **** 	 * Check whether the piece would intersect with any board
 195:board.c       **** 	 * pieces if it dropped one position 
 196:board.c       **** 	 */
 197:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num - 1)) {
 198:board.c       **** 		return 0;
 199:board.c       **** 	}
 200:board.c       **** 	
 201:board.c       **** 	/*
 202:board.c       **** 	 * Only get here if piece drop would succeed - make it happen
 203:board.c       **** 	 */
 204:board.c       **** 	piece_row_num--;
 205:board.c       **** 	return 1;
 206:board.c       **** }
 207:board.c       **** 
 208:board.c       **** /*
 209:board.c       ****  * Attempt to rotate the piece clockwise 90 degrees. Returns 1 if the
 210:board.c       ****  * rotation is successful, 0 otherwise (e.g. a piece on the board
 211:board.c       ****  * blocks the rotation).
 212:board.c       ****  */
 213:board.c       **** int8_t attempt_rotation(void) {
 214:board.c       **** 	/* We calculate what the rotated piece would look like, 
 215:board.c       **** 	 * then compute if it would interect with any board pieces
 216:board.c       **** 	 */
 217:board.c       **** 	piece_type backup_piece;
 218:board.c       **** 	
 219:board.c       **** 	/*
 220:board.c       **** 	 * Make a copy of our piece in its current orientation (in case
 221:board.c       **** 	 * we need to restore it)
 222:board.c       **** 	 */
 223:board.c       **** 	copy_piece(&current_piece, &backup_piece);
 224:board.c       **** 
 225:board.c       **** 	/*
 226:board.c       **** 	 * Attempt rotation (will only fail if too close to right hand
 227:board.c       **** 	 * side)
 228:board.c       **** 	 */
 229:board.c       **** 	if(!rotate_piece(&current_piece)) {
 230:board.c       **** 		return 0;
 231:board.c       **** 	}
 232:board.c       **** 	
 233:board.c       **** 	/* 
 234:board.c       **** 	 * Need to check if rotated piece will intersect with existing
 235:board.c       **** 	 * pieces. If yes, restore old piece and return failure
 236:board.c       **** 	 */
 237:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 238:board.c       **** 		/*
 239:board.c       **** 		 * Current board position does not allow move.
 240:board.c       **** 		 * Restore original piece
 241:board.c       **** 		 */
 242:board.c       **** 		copy_piece(&backup_piece, &current_piece);
 243:board.c       **** 		return 0;
 244:board.c       **** 	}
 245:board.c       **** 	
 246:board.c       **** 	/* Move has been made - return success */
 247:board.c       **** 	return 1;
 248:board.c       **** }
 249:board.c       **** 
 250:board.c       **** 
 251:board.c       **** /*
 252:board.c       ****  * Add piece to board at its current position. We do this using a
 253:board.c       ****  * bitwise OR for each row that contains the piece.
 254:board.c       ****  */
 255:board.c       **** void fix_piece_to_board(void) {
 241               		.loc 1 255 0
 242               		.cfi_startproc
 243               	/* prologue: function */
 244               	/* frame size = 0 */
 245               	/* stack size = 0 */
 246               	.L__stack_usage = 0
 247               	.LVL9:
 256:board.c       **** 	int8_t i;
 257:board.c       **** 	for(i=0; i < current_piece.y_dimension; i++) {
 248               		.loc 1 257 0
 249 00f4 A0E0      		ldi r26,lo8(current_piece)
 250 00f6 B0E0      		ldi r27,hi8(current_piece)
 258:board.c       **** 		board[piece_row_num + i] |= current_piece.rowdata[i];
 251               		.loc 1 258 0
 252 00f8 E091 0000 		lds r30,piece_row_num
 253 00fc FF27      		clr r31
 254 00fe E7FD      		sbrc r30,7
 255 0100 F095      		com r31
 255:board.c       **** void fix_piece_to_board(void) {
 256               		.loc 1 255 0
 257 0102 E050      		subi r30,lo8(-(board))
 258 0104 F040      		sbci r31,hi8(-(board))
 259 0106 2091 0000 		lds r18,current_piece+4
 257:board.c       **** 	for(i=0; i < current_piece.y_dimension; i++) {
 260               		.loc 1 257 0
 261 010a 80E0      		ldi r24,lo8(0)
 262 010c 00C0      		rjmp .L13
 263               	.LVL10:
 264               	.L14:
 265               		.loc 1 258 0 discriminator 2
 266 010e 3D91      		ld r19,X+
 267 0110 9081      		ld r25,Z
 268 0112 932B      		or r25,r19
 269 0114 9193      		st Z+,r25
 257:board.c       **** 	for(i=0; i < current_piece.y_dimension; i++) {
 270               		.loc 1 257 0 discriminator 2
 271 0116 8F5F      		subi r24,lo8(-(1))
 272               	.LVL11:
 273               	.L13:
 257:board.c       **** 	for(i=0; i < current_piece.y_dimension; i++) {
 274               		.loc 1 257 0 is_stmt 0 discriminator 1
 275 0118 8217      		cp r24,r18
 276 011a 01F4      		brne .L14
 259:board.c       **** 	}
 260:board.c       **** 	/*
 261:board.c       **** 	 * Indicate that we no longer have a current piece
 262:board.c       **** 	 */
 263:board.c       **** 	piece_row_num = -1;
 277               		.loc 1 263 0 is_stmt 1
 278 011c 8FEF      		ldi r24,lo8(-1)
 279               	.LVL12:
 280 011e 8093 0000 		sts piece_row_num,r24
 281               	/* epilogue start */
 264:board.c       **** 	check_for_completed_rows();
 265:board.c       **** }
 282               		.loc 1 265 0
 283 0122 0895      		ret
 284               		.cfi_endproc
 285               	.LFE7:
 287               	.global	check_for_completed_rows
 289               	check_for_completed_rows:
 290               	.LFB8:
 266:board.c       **** 
 267:board.c       **** void check_for_completed_rows(void) {
 291               		.loc 1 267 0
 292               		.cfi_startproc
 293               	/* prologue: function */
 294               	/* frame size = 0 */
 295               	/* stack size = 0 */
 296               	.L__stack_usage = 0
 297               	/* epilogue start */
 268:board.c       **** 
 269:board.c       **** 	/* YOUR CODE HERE */
 270:board.c       **** 	
 271:board.c       **** 	/* Suggested approach is to iterate over all the rows (0 to
 272:board.c       **** 	 * BOARD_ROWS -1)in the board and check if the row is all ones
 273:board.c       **** 	 * i.e. matches ((1 << BOARD_WIDTH) - 1).
 274:board.c       **** 	 * If a row of all ones is found, the rows above the current
 275:board.c       **** 	 * one should all be moved down one position and a zero row 
 276:board.c       **** 	 * inserted at the top. 
 277:board.c       **** 	 * Repeat this process if more than one completed row is
 278:board.c       **** 	 * found.
 279:board.c       **** 	 *
 280:board.c       **** 	 * e.g. if rows 2 and 4 are completed (all ones), then
 281:board.c       **** 	 * rows 0 and 1 at the bottom will remain unchanged
 282:board.c       **** 	 * old row 3 becomes row 2
 283:board.c       **** 	 * old row 5 becomes row 3
 284:board.c       **** 	 * old row 6 becomes row 4 
 285:board.c       **** 	 * ...
 286:board.c       **** 	 * old row BOARD_ROWS - 1 becomes row BOARD_ROWS - 3;
 287:board.c       **** 	 * row BOARD_ROWS - 2 (second top row) is set to 0
 288:board.c       **** 	 * row BOARD_ROWS - 1 (top row) is set to 0
 289:board.c       **** 	 */
 290:board.c       **** 	
 291:board.c       **** }
 298               		.loc 1 291 0
 299 0124 0895      		ret
 300               		.cfi_endproc
 301               	.LFE8:
 303               	.global	piece_overlap
 305               	piece_overlap:
 306               	.LFB9:
 292:board.c       **** 
 293:board.c       **** /* 
 294:board.c       ****  * Check whether the given piece will intersect with pieces already on the
 295:board.c       ****  * board (assuming the piece is placed at the given row number).
 296:board.c       **** */
 297:board.c       **** int8_t piece_overlap(piece_type* piece, int8_t row_num) {
 307               		.loc 1 297 0
 308               		.cfi_startproc
 309               	.LVL13:
 310               	/* prologue: function */
 311               	/* frame size = 0 */
 312               	/* stack size = 0 */
 313               	.L__stack_usage = 0
 314 0126 DC01      		movw r26,r24
 315               	.LVL14:
 298:board.c       **** 	int8_t row;
 299:board.c       **** 	for(row=0; row < piece->y_dimension; row++) {
 316               		.loc 1 299 0
 317 0128 1496      		adiw r26,4
 318 012a 2C91      		ld r18,X
 319 012c 1497      		sbiw r26,4
 320 012e 30E0      		ldi r19,lo8(0)
 321 0130 80E0      		ldi r24,lo8(0)
 322 0132 90E0      		ldi r25,hi8(0)
 323               	.LVL15:
 297:board.c       **** int8_t piece_overlap(piece_type* piece, int8_t row_num) {
 324               		.loc 1 297 0
 325 0134 7727      		clr r23
 326 0136 67FD      		sbrc r22,7
 327 0138 7095      		com r23
 328 013a 6050      		subi r22,lo8(-(board))
 329 013c 7040      		sbci r23,hi8(-(board))
 330               	.LVL16:
 331               		.loc 1 299 0
 332 013e 00C0      		rjmp .L17
 333               	.LVL17:
 334               	.L19:
 300:board.c       **** 		if(piece->rowdata[row] & board[row_num + row]) {
 335               		.loc 1 300 0
 336 0140 4D91      		ld r20,X+
 297:board.c       **** int8_t piece_overlap(piece_type* piece, int8_t row_num) {
 337               		.loc 1 297 0
 338 0142 FB01      		movw r30,r22
 339 0144 E80F      		add r30,r24
 340 0146 F91F      		adc r31,r25
 341               		.loc 1 300 0
 342 0148 5081      		ld r21,Z
 343 014a 4523      		and r20,r21
 344 014c 0196      		adiw r24,1
 345 014e 4423      		tst r20
 346 0150 01F4      		brne .L20
 347               	.L17:
 299:board.c       **** 	for(row=0; row < piece->y_dimension; row++) {
 348               		.loc 1 299 0 discriminator 1
 349 0152 8217      		cp r24,r18
 350 0154 9307      		cpc r25,r19
 351 0156 04F0      		brlt .L19
 301:board.c       **** 			/* Got an intersection (AND is non-zero) */
 302:board.c       **** 			return 1;
 303:board.c       **** 		}
 304:board.c       **** 	}
 305:board.c       **** 	return 0;
 352               		.loc 1 305 0
 353 0158 80E0      		ldi r24,lo8(0)
 354 015a 0895      		ret
 355               	.L20:
 302:board.c       **** 			return 1;
 356               		.loc 1 302 0
 357 015c 81E0      		ldi r24,lo8(1)
 306:board.c       **** }
 358               		.loc 1 306 0
 359 015e 0895      		ret
 360               		.cfi_endproc
 361               	.LFE9:
 363               	.global	attempt_rotation
 365               	attempt_rotation:
 366               	.LFB6:
 213:board.c       **** int8_t attempt_rotation(void) {
 367               		.loc 1 213 0
 368               		.cfi_startproc
 369 0160 CF93      		push r28
 370               	.LCFI8:
 371               		.cfi_def_cfa_offset 3
 372               		.cfi_offset 28, -2
 373 0162 DF93      		push r29
 374               	.LCFI9:
 375               		.cfi_def_cfa_offset 4
 376               		.cfi_offset 29, -3
 377 0164 00D0      		rcall .
 378 0166 00D0      		rcall .
 379 0168 00D0      		rcall .
 380               	.LCFI10:
 381               		.cfi_def_cfa_offset 10
 382 016a CDB7      		in r28,__SP_L__
 383 016c DEB7      		in r29,__SP_H__
 384               	.LCFI11:
 385               		.cfi_def_cfa_register 28
 386               	/* prologue: function */
 387               	/* frame size = 6 */
 388               	/* stack size = 8 */
 389               	.L__stack_usage = 8
 223:board.c       **** 	copy_piece(&current_piece, &backup_piece);
 390               		.loc 1 223 0
 391 016e 80E0      		ldi r24,lo8(current_piece)
 392 0170 90E0      		ldi r25,hi8(current_piece)
 393 0172 BE01      		movw r22,r28
 394 0174 6F5F      		subi r22,lo8(-(1))
 395 0176 7F4F      		sbci r23,hi8(-(1))
 396 0178 0E94 0000 		call copy_piece
 229:board.c       **** 	if(!rotate_piece(&current_piece)) {
 397               		.loc 1 229 0
 398 017c 80E0      		ldi r24,lo8(current_piece)
 399 017e 90E0      		ldi r25,hi8(current_piece)
 400 0180 0E94 0000 		call rotate_piece
 401 0184 8823      		tst r24
 402 0186 01F0      		breq .L23
 237:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 403               		.loc 1 237 0
 404 0188 80E0      		ldi r24,lo8(current_piece)
 405 018a 90E0      		ldi r25,hi8(current_piece)
 406 018c 6091 0000 		lds r22,piece_row_num
 407 0190 0E94 0000 		call piece_overlap
 408 0194 8823      		tst r24
 409 0196 01F0      		breq .L24
 242:board.c       **** 		copy_piece(&backup_piece, &current_piece);
 410               		.loc 1 242 0
 411 0198 CE01      		movw r24,r28
 412 019a 0196      		adiw r24,1
 413 019c 60E0      		ldi r22,lo8(current_piece)
 414 019e 70E0      		ldi r23,hi8(current_piece)
 415 01a0 0E94 0000 		call copy_piece
 416               	.L23:
 230:board.c       **** 		return 0;
 417               		.loc 1 230 0
 418 01a4 80E0      		ldi r24,lo8(0)
 419 01a6 00C0      		rjmp .L22
 420               	.L24:
 247:board.c       **** 	return 1;
 421               		.loc 1 247 0
 422 01a8 81E0      		ldi r24,lo8(1)
 423               	.L22:
 424               	/* epilogue start */
 248:board.c       **** }
 425               		.loc 1 248 0
 426 01aa 2696      		adiw r28,6
 427 01ac 0FB6      		in __tmp_reg__,__SREG__
 428 01ae F894      		cli
 429 01b0 DEBF      		out __SP_H__,r29
 430 01b2 0FBE      		out __SREG__,__tmp_reg__
 431 01b4 CDBF      		out __SP_L__,r28
 432 01b6 DF91      		pop r29
 433 01b8 CF91      		pop r28
 434 01ba 0895      		ret
 435               		.cfi_endproc
 436               	.LFE6:
 438               	.global	attempt_drop_piece_one_row
 440               	attempt_drop_piece_one_row:
 441               	.LFB5:
 183:board.c       **** int8_t attempt_drop_piece_one_row(void) {
 442               		.loc 1 183 0
 443               		.cfi_startproc
 444 01bc CF93      		push r28
 445               	.LCFI12:
 446               		.cfi_def_cfa_offset 3
 447               		.cfi_offset 28, -2
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 1 */
 451               	.L__stack_usage = 1
 189:board.c       **** 	if(piece_row_num == 0) {
 452               		.loc 1 189 0
 453 01be C091 0000 		lds r28,piece_row_num
 454 01c2 CC23      		tst r28
 455 01c4 01F0      		breq .L28
 197:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num - 1)) {
 456               		.loc 1 197 0
 457 01c6 C150      		subi r28,lo8(-(-1))
 458 01c8 80E0      		ldi r24,lo8(current_piece)
 459 01ca 90E0      		ldi r25,hi8(current_piece)
 460 01cc 6C2F      		mov r22,r28
 461 01ce 0E94 0000 		call piece_overlap
 462 01d2 8823      		tst r24
 463 01d4 01F4      		brne .L28
 204:board.c       **** 	piece_row_num--;
 464               		.loc 1 204 0
 465 01d6 C093 0000 		sts piece_row_num,r28
 205:board.c       **** 	return 1;
 466               		.loc 1 205 0
 467 01da 81E0      		ldi r24,lo8(1)
 468 01dc 00C0      		rjmp .L26
 469               	.L28:
 198:board.c       **** 		return 0;
 470               		.loc 1 198 0
 471 01de 80E0      		ldi r24,lo8(0)
 472               	.L26:
 473               	/* epilogue start */
 206:board.c       **** }
 474               		.loc 1 206 0
 475 01e0 CF91      		pop r28
 476 01e2 0895      		ret
 477               		.cfi_endproc
 478               	.LFE5:
 480               	.global	attempt_move
 482               	attempt_move:
 483               	.LFB4:
 134:board.c       **** int8_t attempt_move(int8_t direction) {	
 484               		.loc 1 134 0
 485               		.cfi_startproc
 486               	.LVL18:
 487 01e4 1F93      		push r17
 488               	.LCFI13:
 489               		.cfi_def_cfa_offset 3
 490               		.cfi_offset 17, -2
 491 01e6 CF93      		push r28
 492               	.LCFI14:
 493               		.cfi_def_cfa_offset 4
 494               		.cfi_offset 28, -3
 495 01e8 DF93      		push r29
 496               	.LCFI15:
 497               		.cfi_def_cfa_offset 5
 498               		.cfi_offset 29, -4
 499 01ea 00D0      		rcall .
 500 01ec 00D0      		rcall .
 501 01ee 00D0      		rcall .
 502               	.LCFI16:
 503               		.cfi_def_cfa_offset 11
 504 01f0 CDB7      		in r28,__SP_L__
 505 01f2 DEB7      		in r29,__SP_H__
 506               	.LCFI17:
 507               		.cfi_def_cfa_register 28
 508               	/* prologue: function */
 509               	/* frame size = 6 */
 510               	/* stack size = 9 */
 511               	.L__stack_usage = 9
 512 01f4 182F      		mov r17,r24
 141:board.c       **** 	copy_piece(&current_piece, &backup_piece);
 513               		.loc 1 141 0
 514 01f6 80E0      		ldi r24,lo8(current_piece)
 515 01f8 90E0      		ldi r25,hi8(current_piece)
 516               	.LVL19:
 517 01fa BE01      		movw r22,r28
 518 01fc 6F5F      		subi r22,lo8(-(1))
 519 01fe 7F4F      		sbci r23,hi8(-(1))
 520 0200 0E94 0000 		call copy_piece
 148:board.c       **** 		if(!move_piece_left(&current_piece)) {
 521               		.loc 1 148 0
 522 0204 80E0      		ldi r24,lo8(current_piece)
 523 0206 90E0      		ldi r25,hi8(current_piece)
 147:board.c       **** 	if(direction == MOVE_LEFT) {
 524               		.loc 1 147 0
 525 0208 1123      		tst r17
 526 020a 01F4      		brne .L30
 148:board.c       **** 		if(!move_piece_left(&current_piece)) {
 527               		.loc 1 148 0
 528 020c 0E94 0000 		call move_piece_left
 529 0210 00C0      		rjmp .L36
 530               	.L30:
 152:board.c       **** 		if(!move_piece_right(&current_piece)) {
 531               		.loc 1 152 0
 532 0212 0E94 0000 		call move_piece_right
 533               	.L36:
 534 0216 8823      		tst r24
 535 0218 01F0      		breq .L34
 162:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 536               		.loc 1 162 0
 537 021a 80E0      		ldi r24,lo8(current_piece)
 538 021c 90E0      		ldi r25,hi8(current_piece)
 539 021e 6091 0000 		lds r22,piece_row_num
 540 0222 0E94 0000 		call piece_overlap
 541 0226 8823      		tst r24
 542 0228 01F0      		breq .L35
 167:board.c       **** 		copy_piece(&backup_piece, &current_piece);
 543               		.loc 1 167 0
 544 022a CE01      		movw r24,r28
 545 022c 0196      		adiw r24,1
 546 022e 60E0      		ldi r22,lo8(current_piece)
 547 0230 70E0      		ldi r23,hi8(current_piece)
 548 0232 0E94 0000 		call copy_piece
 549               	.L34:
 153:board.c       **** 			return 0;
 550               		.loc 1 153 0
 551 0236 80E0      		ldi r24,lo8(0)
 552 0238 00C0      		rjmp .L31
 553               	.L35:
 172:board.c       **** 	return 1;
 554               		.loc 1 172 0
 555 023a 81E0      		ldi r24,lo8(1)
 556               	.L31:
 557               	/* epilogue start */
 173:board.c       **** }
 558               		.loc 1 173 0
 559 023c 2696      		adiw r28,6
 560 023e 0FB6      		in __tmp_reg__,__SREG__
 561 0240 F894      		cli
 562 0242 DEBF      		out __SP_H__,r29
 563 0244 0FBE      		out __SREG__,__tmp_reg__
 564 0246 CDBF      		out __SP_L__,r28
 565 0248 DF91      		pop r29
 566 024a CF91      		pop r28
 567 024c 1F91      		pop r17
 568               	.LVL20:
 569 024e 0895      		ret
 570               		.cfi_endproc
 571               	.LFE4:
 573               	.global	add_random_piece
 575               	add_random_piece:
 576               	.LFB3:
 104:board.c       **** int8_t add_random_piece(void) {
 577               		.loc 1 104 0
 578               		.cfi_startproc
 579 0250 CF93      		push r28
 580               	.LCFI18:
 581               		.cfi_def_cfa_offset 3
 582               		.cfi_offset 28, -2
 583 0252 DF93      		push r29
 584               	.LCFI19:
 585               		.cfi_def_cfa_offset 4
 586               		.cfi_offset 29, -3
 587 0254 00D0      		rcall .
 588 0256 00D0      		rcall .
 589 0258 00D0      		rcall .
 590               	.LCFI20:
 591               		.cfi_def_cfa_offset 10
 592 025a CDB7      		in r28,__SP_L__
 593 025c DEB7      		in r29,__SP_H__
 594               	.LCFI21:
 595               		.cfi_def_cfa_register 28
 596               	/* prologue: function */
 597               	/* frame size = 6 */
 598               	/* stack size = 8 */
 599               	.L__stack_usage = 8
 105:board.c       **** 	current_piece = generate_random_piece();
 600               		.loc 1 105 0
 601 025e 0E94 0000 		call generate_random_piece
 602 0262 2983      		std Y+1,r18
 603 0264 3A83      		std Y+2,r19
 604 0266 4B83      		std Y+3,r20
 605 0268 5C83      		std Y+4,r21
 606 026a 6D83      		std Y+5,r22
 607 026c 7E83      		std Y+6,r23
 608 026e A0E0      		ldi r26,lo8(current_piece)
 609 0270 B0E0      		ldi r27,hi8(current_piece)
 610 0272 FE01      		movw r30,r28
 611 0274 3196      		adiw r30,1
 612 0276 86E0      		ldi r24,lo8(6)
 613               	.L38:
 614 0278 0190      		ld r0,Z+
 615 027a 0D92      		st X+,r0
 616 027c 8150      		subi r24,lo8(-(-1))
 617 027e 01F4      		brne .L38
 113:board.c       **** 	if(current_piece.x_dimension > current_piece.y_dimension) {
 618               		.loc 1 113 0
 619 0280 2091 0000 		lds r18,current_piece+3
 620 0284 9091 0000 		lds r25,current_piece+4
 114:board.c       **** 		piece_row_num = BOARD_ROWS - current_piece.x_dimension;
 621               		.loc 1 114 0
 622 0288 8FE0      		ldi r24,lo8(15)
 113:board.c       **** 	if(current_piece.x_dimension > current_piece.y_dimension) {
 623               		.loc 1 113 0
 624 028a 9217      		cp r25,r18
 625 028c 00F4      		brsh .L39
 114:board.c       **** 		piece_row_num = BOARD_ROWS - current_piece.x_dimension;
 626               		.loc 1 114 0
 627 028e 821B      		sub r24,r18
 628 0290 00C0      		rjmp .L44
 629               	.L39:
 116:board.c       **** 		piece_row_num = BOARD_ROWS - current_piece.y_dimension;
 630               		.loc 1 116 0
 631 0292 891B      		sub r24,r25
 632               	.L44:
 633 0294 8093 0000 		sts piece_row_num,r24
 118:board.c       **** 	if(piece_overlap(&current_piece, piece_row_num)) {
 634               		.loc 1 118 0
 635 0298 80E0      		ldi r24,lo8(current_piece)
 636 029a 90E0      		ldi r25,hi8(current_piece)
 637 029c 6091 0000 		lds r22,piece_row_num
 638 02a0 0E94 0000 		call piece_overlap
 639 02a4 8823      		tst r24
 640 02a6 01F0      		breq .L42
 120:board.c       **** 		piece_row_num = -1; /* no current piece */
 641               		.loc 1 120 0
 642 02a8 8FEF      		ldi r24,lo8(-1)
 643 02aa 8093 0000 		sts piece_row_num,r24
 121:board.c       **** 		return 0;
 644               		.loc 1 121 0
 645 02ae 80E0      		ldi r24,lo8(0)
 646 02b0 00C0      		rjmp .L41
 647               	.L42:
 123:board.c       **** 		return 1;
 648               		.loc 1 123 0
 649 02b2 81E0      		ldi r24,lo8(1)
 650               	.L41:
 651               	/* epilogue start */
 125:board.c       **** }
 652               		.loc 1 125 0
 653 02b4 2696      		adiw r28,6
 654 02b6 0FB6      		in __tmp_reg__,__SREG__
 655 02b8 F894      		cli
 656 02ba DEBF      		out __SP_H__,r29
 657 02bc 0FBE      		out __SREG__,__tmp_reg__
 658 02be CDBF      		out __SP_L__,r28
 659 02c0 DF91      		pop r29
 660 02c2 CF91      		pop r28
 661 02c4 0895      		ret
 662               		.cfi_endproc
 663               	.LFE3:
 665               		.comm piece_row_num,1,1
 666               		.comm current_piece,6,1
 667               		.comm board,15,1
 668               	.Letext0:
 669               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 670               		.file 3 "pieces.h"
 671               		.file 4 "led_display.h"
DEFINED SYMBOLS
                            *ABS*:00000000 board.c
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:2      *ABS*:0000003f __SREG__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:3      *ABS*:0000003e __SP_H__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:4      *ABS*:0000003d __SP_L__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:5      *ABS*:00000034 __CCP__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:7      *ABS*:00000001 __zero_reg__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:15     .text:00000000 init_board
                            *COM*:0000000f board
                            *COM*:00000001 piece_row_num
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:47     .text:00000014 copy_board_to_led_display
                            *COM*:00000006 current_piece
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:217    .text:000000e6 have_current_piece
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:239    .text:000000f4 fix_piece_to_board
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:289    .text:00000124 check_for_completed_rows
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:305    .text:00000126 piece_overlap
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:365    .text:00000160 attempt_rotation
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:440    .text:000001bc attempt_drop_piece_one_row
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:482    .text:000001e4 attempt_move
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//ccDYCoFY.s:575    .text:00000250 add_random_piece

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
display
copy_piece
rotate_piece
move_piece_left
move_piece_right
generate_random_piece
