   1               		.file	"keypad.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	init_keypad
  15               	init_keypad:
  16               	.LFB1:
  17               		.file 1 "keypad.c"
   1:keypad.c      **** /*
   2:keypad.c      ****  * keypad.c
   3:keypad.c      ****  *
   4:keypad.c      ****  * Written by: Peter Sutton
   5:keypad.c      ****  */ 
   6:keypad.c      **** 
   7:keypad.c      **** #include <stdint.h>
   8:keypad.c      **** #ifdef AVR
   9:keypad.c      **** #include <avr/io.h>
  10:keypad.c      **** #include <avr/interrupt.h>
  11:keypad.c      **** #else
  12:keypad.c      **** #include <unistd.h>
  13:keypad.c      **** #endif
  14:keypad.c      **** #include "keypad.h"
  15:keypad.c      **** 
  16:keypad.c      **** #include <stdio.h>
  17:keypad.c      **** 
  18:keypad.c      **** /* Last button pushed - initially NULL. */
  19:keypad.c      **** static char last_button_pushed = 0;
  20:keypad.c      **** 
  21:keypad.c      **** #ifdef AVR
  22:keypad.c      **** /* Symbol table - 2D array which we can reference with [row][col] to
  23:keypad.c      ****  * determine the button that has been pushed. Rows are 1 to 4, columns
  24:keypad.c      ****  * are 1 to 4. Row 0 and column 0 values are irrelevant and won't be used
  25:keypad.c      ****  * so we just make those null characters.
  26:keypad.c      ****  */
  27:keypad.c      **** static char keypad_buttons[5][5] = 
  28:keypad.c      **** 		{	{0,   0,   0,   0,   0 },
  29:keypad.c      **** 			{0,  '1', '2', '3', 'A'},
  30:keypad.c      **** 			{0,  '4', '5', '6', 'B'},
  31:keypad.c      **** 			{0,  '7', '8', '9', 'C'},
  32:keypad.c      **** 			{0,  '0', 'F', 'E', 'D'}
  33:keypad.c      **** 		};
  34:keypad.c      **** 
  35:keypad.c      **** /* Variable which indicates which column is live (column line pulled low).
  36:keypad.c      ****  * We start with no columns pulled low.
  37:keypad.c      ****  */
  38:keypad.c      **** static uint8_t active_column;
  39:keypad.c      **** 
  40:keypad.c      **** /* Port E output values when checking each column. Indexed by column 1 to 4, index 0 is
  41:keypad.c      ****  * irrelevant. We output a 0 to the specific column and a 1 to the others. Lower 4 bits are
  42:keypad.c      ****  * irrelevant - these bits are used for RS232 communications. Connections are as follows:
  43:keypad.c      ****  * Column 1 - PMOD pin 4 - port E, pin 5
  44:keypad.c      ****  * Column 2 - PMOD pin 3 - port E, pin 7
  45:keypad.c      ****  * Column 3 - PMOD pin 2 - port E, pin 4
  46:keypad.c      ****  * Column 4 - PMOD pin 1 - port E, pin 6
  47:keypad.c      ****  */
  48:keypad.c      **** static uint8_t portE_column_strobe_values[5] = 
  49:keypad.c      **** 		{	0,	/* index 0 is irrelevant - this is padding */
  50:keypad.c      **** 			0xD0,	/* 11010000 */
  51:keypad.c      **** 			0x70,	/* 01110000 */
  52:keypad.c      **** 			0xE0,	/* 11100000 */
  53:keypad.c      **** 			0xB0	/* 10110000 */			
  54:keypad.c      **** 		};
  55:keypad.c      **** #endif
  56:keypad.c      **** 		
  57:keypad.c      **** /* A pointer to the handler we'll call when a button is pushed. The user supplies
  58:keypad.c      ****  * the handler when this module is initialised.
  59:keypad.c      ****  */
  60:keypad.c      **** static BUTTONHANDLER* button_handler;
  61:keypad.c      **** 
  62:keypad.c      **** /* See documentation in .h file
  63:keypad.c      ****  */
  64:keypad.c      **** void init_keypad(BUTTONHANDLER* handler_function_ptr) {
  18               		.loc 1 64 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  65:keypad.c      **** #ifdef AVR
  66:keypad.c      **** 	/* Make the upper 4 bits of port E be outputs.
  67:keypad.c      **** 	 * These are our column lines. We initially drive them
  68:keypad.c      **** 	 * all as 1's. The lower 4 bits are left as inputs.
  69:keypad.c      **** 	 */
  70:keypad.c      **** 	DDRE = 0xF0;
  25               		.loc 1 70 0
  26 0000 20EF      		ldi r18,lo8(-16)
  27 0002 22B9      		out 34-32,r18
  71:keypad.c      **** 	PORTE = 0xF0;
  28               		.loc 1 71 0
  29 0004 23B9      		out 35-32,r18
  72:keypad.c      **** 
  73:keypad.c      **** 	/* No column is "active" initially. */
  74:keypad.c      **** 	active_column = 0;
  30               		.loc 1 74 0
  31 0006 1092 0000 		sts active_column,__zero_reg__
  75:keypad.c      **** #endif
  76:keypad.c      **** 	
  77:keypad.c      **** 	/* Store the pointer to the handler we're going to call */
  78:keypad.c      **** 	button_handler = handler_function_ptr;
  32               		.loc 1 78 0
  33 000a 9093 0000 		sts button_handler+1,r25
  34 000e 8093 0000 		sts button_handler,r24
  79:keypad.c      **** 	
  80:keypad.c      **** 	/* No last button pushed */
  81:keypad.c      **** 	last_button_pushed = 0;
  35               		.loc 1 81 0
  36 0012 1092 0000 		sts last_button_pushed,__zero_reg__
  37               	/* epilogue start */
  82:keypad.c      **** }
  38               		.loc 1 82 0
  39 0016 0895      		ret
  40               		.cfi_endproc
  41               	.LFE1:
  43               	.global	check_keypad_column
  45               	check_keypad_column:
  46               	.LFB2:
  83:keypad.c      **** 
  84:keypad.c      **** /* See documentation in .h file.
  85:keypad.c      ****  */
  86:keypad.c      **** void check_keypad_column(void) {
  47               		.loc 1 86 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  87:keypad.c      **** #ifdef AVR
  88:keypad.c      **** 	/* The button state (old row values) is preserved between calls to this function 
  89:keypad.c      **** 	 * so that we can keep track of changes to the state - i.e. when a button is 
  90:keypad.c      **** 	 * pressed that wasn't previously.
  91:keypad.c      **** 	 */
  92:keypad.c      **** 	static uint8_t row_value_old[5];	/* Indexed by column*/
  93:keypad.c      **** 	uint8_t row, row_value, button_pushed;
  94:keypad.c      **** 	
  95:keypad.c      **** 	if(active_column > 0) {
  53               		.loc 1 95 0
  54 0018 4091 0000 		lds r20,active_column
  55 001c 4423      		tst r20
  56 001e 01F4      		brne .+2
  57 0020 00C0      		rjmp .L3
  96:keypad.c      **** 		/* We had an active column - check all the rows to see 
  97:keypad.c      **** 		 * if any buttons were pushed. One of the upper 4 bits
  98:keypad.c      **** 		 * will be 0 if a button has been pushed. (More than one
  99:keypad.c      **** 		 * may be 0 if more than one button has been pushed, but
 100:keypad.c      **** 		 * support for multiple simultaneous button pushes is
 101:keypad.c      **** 		 * not provided.)
 102:keypad.c      **** 		 */
 103:keypad.c      **** 		row_value = ((PIND & (1<<6))>>2) |	/* Pin D6 (row 4) as bit 4 */
  58               		.loc 1 103 0
  59 0022 E0B3      		in r30,48-32
 104:keypad.c      **** 				((PINB & (1<<5))>>2) |		/* Pin B5 (row 3) as bit 3 */
  60               		.loc 1 104 0
  61 0024 66B3      		in r22,54-32
 105:keypad.c      **** 				((PIND & (1<<4))>>2) |		/* Pin D4 (row 2) as bit 2 */
  62               		.loc 1 105 0
  63 0026 20B3      		in r18,48-32
 106:keypad.c      **** 				((PINB & (1<<6))>>5);		/* Pin B6 (row 1) as bit 1 */
  64               		.loc 1 106 0
  65 0028 86B3      		in r24,54-32
 104:keypad.c      **** 				((PINB & (1<<5))>>2) |		/* Pin B5 (row 3) as bit 3 */
  66               		.loc 1 104 0
  67 002a 70E0      		ldi r23,lo8(0)
  68 002c 6072      		andi r22,lo8(32)
  69 002e 7070      		andi r23,hi8(32)
  70 0030 7595      		asr r23
  71 0032 6795      		ror r22
  72 0034 7595      		asr r23
  73 0036 6795      		ror r22
 103:keypad.c      **** 		row_value = ((PIND & (1<<6))>>2) |	/* Pin D6 (row 4) as bit 4 */
  74               		.loc 1 103 0
  75 0038 F0E0      		ldi r31,lo8(0)
  76 003a E074      		andi r30,lo8(64)
  77 003c F070      		andi r31,hi8(64)
  78 003e F595      		asr r31
  79 0040 E795      		ror r30
  80 0042 F595      		asr r31
  81 0044 E795      		ror r30
  82 0046 6E2B      		or r22,r30
 105:keypad.c      **** 				((PIND & (1<<4))>>2) |		/* Pin D4 (row 2) as bit 2 */
  83               		.loc 1 105 0
  84 0048 30E0      		ldi r19,lo8(0)
  85 004a 2071      		andi r18,lo8(16)
  86 004c 3070      		andi r19,hi8(16)
  87 004e 3595      		asr r19
  88 0050 2795      		ror r18
  89 0052 3595      		asr r19
  90 0054 2795      		ror r18
 103:keypad.c      **** 		row_value = ((PIND & (1<<6))>>2) |	/* Pin D6 (row 4) as bit 4 */
  91               		.loc 1 103 0
  92 0056 622B      		or r22,r18
  93               		.loc 1 106 0
  94 0058 90E0      		ldi r25,lo8(0)
  95 005a 8074      		andi r24,lo8(64)
  96 005c 9070      		andi r25,hi8(64)
  97 005e E5E0      		ldi r30,5
  98 0060 9595      	1:	asr r25
  99 0062 8795      		ror r24
 100 0064 EA95      		dec r30
 101 0066 01F4      		brne 1b
 103:keypad.c      **** 		row_value = ((PIND & (1<<6))>>2) |	/* Pin D6 (row 4) as bit 4 */
 102               		.loc 1 103 0
 103 0068 682B      		or r22,r24
 104               	.LVL1:
 107:keypad.c      **** 		if(row_value != row_value_old[active_column]) {
 105               		.loc 1 107 0
 106 006a 50E0      		ldi r21,lo8(0)
 107 006c DA01      		movw r26,r20
 108 006e A050      		subi r26,lo8(-(row_value_old.1443))
 109 0070 B040      		sbci r27,hi8(-(row_value_old.1443))
 110 0072 8C91      		ld r24,X
 111 0074 6817      		cp r22,r24
 112 0076 01F0      		breq .L3
 108:keypad.c      **** 			/* State has changed */
 109:keypad.c      **** 			row_value_old[active_column] = row_value;
 113               		.loc 1 109 0
 114 0078 6C93      		st X,r22
 110:keypad.c      **** 			if(row_value != 0x1E) {
 115               		.loc 1 110 0
 116 007a 6E31      		cpi r22,lo8(30)
 117 007c 01F0      		breq .L3
 118 007e 81E0      		ldi r24,lo8(1)
 119 0080 90E0      		ldi r25,hi8(1)
 111:keypad.c      **** 				/* Button has been pushed - work out which one. */
 112:keypad.c      **** 				for(row = 1; row <= 4; row++) {
 113:keypad.c      **** 					/* Extract whether the button is pushed in the given row.
 114:keypad.c      **** 					 * Row 1 is bit 1, row 2 is bit 2, row 3 is bit 3, row 4 is bit 4.
 115:keypad.c      **** 					 * Button is pushed if bit read is 0.
 116:keypad.c      **** 					 */
 117:keypad.c      **** 					button_pushed = !(row_value & (1<<row));
 120               		.loc 1 117 0
 121 0082 70E0      		ldi r23,lo8(0)
 122               	.L5:
 123 0084 9B01      		movw r18,r22
 124 0086 082E      		mov r0,r24
 125 0088 00C0      		rjmp 2f
 126 008a 3595      	1:	asr r19
 127 008c 2795      		ror r18
 128 008e 0A94      	2:	dec r0
 129 0090 02F4      		brpl 1b
 118:keypad.c      **** 					if(button_pushed) {
 130               		.loc 1 118 0
 131 0092 20FD      		sbrc r18,0
 132 0094 00C0      		rjmp .L4
 119:keypad.c      **** 						/* Button has been pushed so call handler if one was
 120:keypad.c      **** 						 * provided. In any case, we record this as the last 
 121:keypad.c      **** 						 * button pushed.
 122:keypad.c      **** 						 */
 123:keypad.c      **** 						last_button_pushed = keypad_buttons[row][active_column];
 133               		.loc 1 123 0
 134 0096 FC01      		movw r30,r24
 135 0098 EE0F      		lsl r30
 136 009a FF1F      		rol r31
 137 009c EE0F      		lsl r30
 138 009e FF1F      		rol r31
 139 00a0 E80F      		add r30,r24
 140 00a2 F91F      		adc r31,r25
 141 00a4 E40F      		add r30,r20
 142 00a6 F51F      		adc r31,r21
 143 00a8 E050      		subi r30,lo8(-(keypad_buttons))
 144 00aa F040      		sbci r31,hi8(-(keypad_buttons))
 145 00ac 8081      		ld r24,Z
 146 00ae 8093 0000 		sts last_button_pushed,r24
 124:keypad.c      **** 						if(button_handler) {
 147               		.loc 1 124 0
 148 00b2 E091 0000 		lds r30,button_handler
 149 00b6 F091 0000 		lds r31,button_handler+1
 150 00ba 3097      		sbiw r30,0
 151 00bc 01F0      		breq .L3
 125:keypad.c      **** 							(*button_handler)(last_button_pushed);
 152               		.loc 1 125 0
 153 00be 0995      		icall
 154               	.LVL2:
 155 00c0 00C0      		rjmp .L3
 156               	.LVL3:
 157               	.L4:
 158 00c2 0196      		adiw r24,1
 112:keypad.c      **** 				for(row = 1; row <= 4; row++) {
 159               		.loc 1 112 0
 160 00c4 8530      		cpi r24,5
 161 00c6 9105      		cpc r25,__zero_reg__
 162 00c8 01F4      		brne .L5
 163               	.LVL4:
 164               	.L3:
 126:keypad.c      **** 						}						
 127:keypad.c      **** 						/* Drop out of the for loop */
 128:keypad.c      **** 						break;
 129:keypad.c      **** 					}	
 130:keypad.c      **** 				}
 131:keypad.c      **** 			}
 132:keypad.c      **** 		}	
 133:keypad.c      **** 	}
 134:keypad.c      **** 	
 135:keypad.c      **** 	/* Move on to make the next column active - we'll check it the next time
 136:keypad.c      **** 	 * this function is called.
 137:keypad.c      **** 	 */
 138:keypad.c      **** 	active_column++;
 165               		.loc 1 138 0
 166 00ca 8091 0000 		lds r24,active_column
 167 00ce 8F5F      		subi r24,lo8(-(1))
 168 00d0 8093 0000 		sts active_column,r24
 139:keypad.c      **** 	if(active_column > 4) {
 169               		.loc 1 139 0
 170 00d4 8530      		cpi r24,lo8(5)
 171 00d6 00F0      		brlo .L6
 140:keypad.c      **** 		active_column = 1;
 172               		.loc 1 140 0
 173 00d8 81E0      		ldi r24,lo8(1)
 174 00da 8093 0000 		sts active_column,r24
 175               	.L6:
 141:keypad.c      **** 	}
 142:keypad.c      **** 	
 143:keypad.c      **** 	/* Update the port E output value for the new active column.
 144:keypad.c      **** 	 */
 145:keypad.c      **** 	PORTE = portE_column_strobe_values[active_column];
 176               		.loc 1 145 0
 177 00de E091 0000 		lds r30,active_column
 178 00e2 F0E0      		ldi r31,lo8(0)
 179 00e4 E050      		subi r30,lo8(-(portE_column_strobe_values))
 180 00e6 F040      		sbci r31,hi8(-(portE_column_strobe_values))
 181 00e8 8081      		ld r24,Z
 182 00ea 83B9      		out 35-32,r24
 183               	/* epilogue start */
 146:keypad.c      **** #endif
 147:keypad.c      **** }
 184               		.loc 1 147 0
 185 00ec 0895      		ret
 186               		.cfi_endproc
 187               	.LFE2:
 189               	.global	keypad_button_pushed
 191               	keypad_button_pushed:
 192               	.LFB3:
 148:keypad.c      **** 
 149:keypad.c      **** /* Return the last button pushed. If interrupts were on, we turn them off so
 150:keypad.c      ****  * we don't get interrupted between reading and setting the last_button_pushed
 151:keypad.c      ****  * variable.
 152:keypad.c      ****  */
 153:keypad.c      **** char keypad_button_pushed(void) {
 193               		.loc 1 153 0
 194               		.cfi_startproc
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
 154:keypad.c      **** #ifdef AVR
 155:keypad.c      **** 	char c;
 156:keypad.c      **** 	uint8_t interrupts_enabled;
 157:keypad.c      **** 	
 158:keypad.c      **** 	interrupts_enabled = bit_is_set(SREG, SREG_I);
 199               		.loc 1 158 0
 200 00ee 9FB7      		in r25,__SREG__
 201               	.LVL5:
 159:keypad.c      **** 	cli();
 202               		.loc 1 159 0
 203               	/* #APP */
 204               	 ;  159 "keypad.c" 1
 205 00f0 F894      		cli
 206               	 ;  0 "" 2
 160:keypad.c      **** 	c = last_button_pushed;
 207               		.loc 1 160 0
 208               	/* #NOAPP */
 209 00f2 8091 0000 		lds r24,last_button_pushed
 210               	.LVL6:
 161:keypad.c      **** 	last_button_pushed = 0;
 211               		.loc 1 161 0
 212 00f6 1092 0000 		sts last_button_pushed,__zero_reg__
 162:keypad.c      **** 	if(interrupts_enabled) {
 213               		.loc 1 162 0
 214 00fa 97FF      		sbrs r25,7
 215 00fc 00C0      		rjmp .L9
 163:keypad.c      **** 		sei();
 216               		.loc 1 163 0
 217               	/* #APP */
 218               	 ;  163 "keypad.c" 1
 219 00fe 7894      		sei
 220               	 ;  0 "" 2
 221               	/* #NOAPP */
 222               	.L9:
 164:keypad.c      **** 	}
 165:keypad.c      **** 	return c;
 166:keypad.c      **** #else
 167:keypad.c      **** 	/* Non AVR - no keypad button is ever pressed. We put
 168:keypad.c      **** 	 * in a delay for 500 microseconds just so we don't 
 169:keypad.c      **** 	 * chew up too much CPU time with busy waiting.
 170:keypad.c      **** 	 */
 171:keypad.c      **** 	usleep(500);
 172:keypad.c      **** 	return 0;
 173:keypad.c      **** #endif
 174:keypad.c      **** }
 223               		.loc 1 174 0
 224 0100 0895      		ret
 225               		.cfi_endproc
 226               	.LFE3:
 228               		.lcomm active_column,1
 229               		.lcomm button_handler,2
 230               		.lcomm last_button_pushed,1
 231               		.lcomm row_value_old.1443,5
 232               		.data
 235               	keypad_buttons:
 236 0000 00        		.byte	0
 237 0001 00        		.byte	0
 238 0002 00        		.byte	0
 239 0003 00        		.byte	0
 240 0004 00        		.byte	0
 241 0005 00        		.byte	0
 242 0006 31        		.byte	49
 243 0007 32        		.byte	50
 244 0008 33        		.byte	51
 245 0009 41        		.byte	65
 246 000a 00        		.byte	0
 247 000b 34        		.byte	52
 248 000c 35        		.byte	53
 249 000d 36        		.byte	54
 250 000e 42        		.byte	66
 251 000f 00        		.byte	0
 252 0010 37        		.byte	55
 253 0011 38        		.byte	56
 254 0012 39        		.byte	57
 255 0013 43        		.byte	67
 256 0014 00        		.byte	0
 257 0015 30        		.byte	48
 258 0016 46        		.byte	70
 259 0017 45        		.byte	69
 260 0018 44        		.byte	68
 263               	portE_column_strobe_values:
 264 0019 00        		.byte	0
 265 001a D0        		.byte	-48
 266 001b 70        		.byte	112
 267 001c E0        		.byte	-32
 268 001d B0        		.byte	-80
 269               		.text
 270               	.Letext0:
 271               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 272               		.file 3 "keypad.h"
DEFINED SYMBOLS
                            *ABS*:00000000 keypad.c
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:2      *ABS*:0000003f __SREG__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:3      *ABS*:0000003e __SP_H__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:4      *ABS*:0000003d __SP_L__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:5      *ABS*:00000034 __CCP__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:7      *ABS*:00000001 __zero_reg__
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:15     .text:00000000 init_keypad
                             .bss:00000000 active_column
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:228    .bss:00000001 button_handler
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:229    .bss:00000003 last_button_pushed
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:45     .text:00000018 check_keypad_column
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:230    .bss:00000004 row_value_old.1443
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:235    .data:00000000 keypad_buttons
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:263    .data:00000019 portE_column_strobe_values
/var/folders/5q/cbspj09573sdz95ppjc1lv4w0000gn/T//cc9bGhJb.s:191    .text:000000ee keypad_button_pushed

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
